# topコマンド

topコマンドを利用すると、その計算機で動作しているプログラムのうち、どれがCPU時間を消費しているかや、
どれがメモリを占有しているかを確認できます。

以下のように呼び出します。
```
top
```
以下のように表示されます。
```top - 14:57:55 up 71 days,  5:13,  4 users,  load average: 0.01, 0.02, 0.05
Tasks: 734 total,   1 running, 733 sleeping,   0 stopped,   0 zombie
%Cpu(s):  0.1 us,  0.2 sy,  0.0 ni, 99.7 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st
KiB Mem : 52808937+total, 45810416+free,  7178816 used, 62806404 buff/cache
KiB Swap:  4194300 total,  3951808 free,   242492 used. 51950041+avail Mem

  PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND
12943 sequser   20   0  162792   2728   1544 R  11.8  0.0   0:00.04 top
    1 root      20   0  191796   3544   1768 S   0.0  0.0   5:35.21 systemd
    2 root      20   0       0      0      0 S   0.0  0.0   0:03.20 kthreadd
    4 root       0 -20       0      0      0 S   0.0  0.0   0:00.00 kworker/0:0H
    6 root      20   0       0      0      0 S   0.0  0.0   0:09.53 ksoftirqd/0
    7 root      rt   0       0      0      0 S   0.0  0.0   0:22.46 migration/0
```

topの表示の上の方はサマリー情報で、大事な項目の見方は覚えておきましょう。
- load average
  - 右上に3つ小数が表示されており、左から順に直近1分間、5分間、15分間の計算機の負荷(load)が表示されています。
- KiB Mem
  - この計算機の物理メモリ量が表示されています。この例では桁が表示しきれず切れていますが約512GBです。

メモリの現在の使用量なども表示されていますが、性能を低下させる要因をここから読み取るのは現在のLinuxでは難しくなってしまったので、ここでは説明は割愛します。

topコマンドで下の方はタスクエリアと呼ばれるタスクの一覧です。タスクというのは、単純な状況ではタスク＝プロセス＝ジョブという状況です。
実行中のプログラムをどの視点で見るかによって呼称が変わるようですが、ユーザ vs OSの図式の中で、プロセスというのが最も意味が厳密で
OS上で動作するプログラムの基本的な実行単位です。
ジョブというのはシェルやSGEのようなジョブスケジューラがプロセスを指してそのように呼び、一般的にはジョブはユーザに近い見方で、
プロセスはOSに近い見方なので、ジョブの方はユーザのコマンドやソフトウェアによってキューイング(待ち)されたり、Ctrl-Zでサスペンドされたり、
fgコマンドで再開されたりします。タスクという言葉はOSの用語としてはプロセスほど厳密な意味は持たないようですが、OS側から見たプロセスやジョブのことを指します。
```man pidstat```などの説明を読むとタスクという言葉が好んで使われているようです。

タスクエリアに表示されている内容を確認していきましょう
- PID
  - Process IDの略です。killコマンドや、pidstatなど様々なコマンドで利用できるIDなので重要です。
- USER
  - そのプログラムを実行しているユーザアカウント名です
- PR
  - Priorityです。デフォルトの優先度は20で、最高の0から最低の39まであります。rootであればreniceコマンドで上げ下げは自由で
    一般のユーザは下げることしかできません。コマンドの実行時にniceコマンドで指定することもできます。
- NI
  - nice(ナイス)値と呼ばれる優先度の調整値で、nice -n 10 [コマンド] として実行した場合にここに10と表示され、PRはnice値を合計された30という
    低い優先度での実行になります。
- VIRT
  - 仮想メモリ容量です。スワップアウトしてHDDなどのスワップ領域に追い出された領域の容量も含みます。
- RES
  - Resident Memory Sizeのことで、実際の物理メモリの使用量です。これは非常に重要で何かあった際は見ておかなければなりません。
- SHR
  - Shared memory Sizeでプロセス間の通信に使用する共有メモリのサイズです。
- S
  - Process Statusで、プロセスの状態を示します。1文字のアルファベットの意味は下記の表を参照してください。
- %CPU
  - CPU使用率です。これも重要です。2コアをフル回転させると200%になります。
- %MEM
  - メモリ使用率です。
- TIME
  - CPU時間、つまりCPUを使用した時間の累積値です。マルチスレッドで2コアを1時間使うとCPU時間は2時間になります。CPU+の場合は秒単位で表示されます。
- COMMAND
  - そのプロセスのコマンドとしての表記です

## Process Status
|Status | 意味 |
| ------------- | ------------- |
| D | uninterruptible sleep|
| R | running |
| S | sleeping|
| T | stopped by job control signal|
| t | stopped by debugger during trace|
| Z | zombie|

## topで、何を見るか

### CPUが効率的に使用されているか
マルチスレッドのプログラムをスレッド数4を指定して動作させた場合、CPUがフル回転できていれば、%CPUは400%となり、
そのような状況が理想的です。

計算の目的がデータのコピー等でなければ、基本的にはCPUをどれだけ効率的に回せたかが
性能を引き出せたかということになります。CPUがフル回転できない状況に陥っている場合には、
その原因を調査して、問題を取り除いてCPUが存分に仕事ができるようにする必要があります。

1. メモリは足りているか
   - RESの値は、キーボードでMをタイプすると使用量の多い順にソートできます。ソートしてみて
     上位のプロセスの使用メモリ容量を合計して計算機の物理メモリ容量を超えていないか
     確認してください。超えてしまっている場合は、メモリを増設したり、同時に動かすプログラムを
     減らすなどの対策が必要になります。
2. load averageが異常に高くないか
   - load averageは負荷の総合的な値で、おおむね1コア計算機が効率的に動作した場合の最大は１で、4コアの計算機の場合は4となります。
     もし、その値を越えている場合は過負荷な状態なので、プログラムの起動しすぎなどでコンテキストスイッチやIOの競合が発生して
     性能が低下している可能性があります。
3. CPU利用率は高いか
   - キーボードでPをタイプするとCPU利用率の高い順にタスクがソートされるので、自分の実行したプログラムが
     どの程度CPUを利用できているかを確認できます。例えばbwaのようなマルチスレッドのプログラムでも起動直後の
     リファレンスゲノムのインデックスの読込ではマルチスレッドでは動かず、その後にマッピングが始まると
    複数スレッドで複数コアを使用するので、最初に少し見ただけでは分からない場合もあります。
      またPでソートしても上位に上って来ない場合は、何か問題があって実質的に停止していることになります。

メモリが足りない場合やloadが高すぎる場合、以下のような対策が可能です
- プログラムを強制終了する
  - kill -HUP やkill -KILLなどで他のプログラムを強制終了させてしまえば余裕ができます。
- プログラムを一時停止する
  - kill -STOPでプログラムを一時停止させ、計算機が空いた時点でkill -CONTで再開させることができます
- プログラムの優先度を下げる
  - 同じ優先度でたくさんのプログラムが実行中で、どれも止めることができない場合は、reniceコマンドで
    一部のプロセスの優先度を下げてやると効率的にCPUを回せるようになる場合もあります。IOインテンシブな計算の場合は
    ioniceの利用も検討してください。

物理メモリ容量が不足している場合、OSは異常終了させないように仮想メモリを利用して計算を続行させようとしますが、
科学計算においてはHDDのように遅いデバイス上にメモリのデータを置かれてしまうと計算速度が1/100以下に低下して
しまうなどするため、現実的ではなく、強制終了せざるをえないことも多いです。

このため、メモリ使用量は計算開始前に見積っておき、複数起動する場合はそれらの合計が物理メモリ容量を越えないように
プログラムを起動する数を抑制しておく必要があります。

ちなみにjavaでは-Xmx 512gのようにオプションで最大メモリ容量を指定して起動することができますが、javaの仮想マシンは
指定の1.5倍程度使用してしまうとがあるようなので、700GB以上の物理メモリが必要かもしれません。
